# Словарик

- В PHP
    - Регулярные выражения
        
        [Регулярные выражения - JavaScript | MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_Expressions)
        
    - JMS Serialise
        
        
    - Chain adapter cache Symfony
    - Вероятностный кеш
    - CRC(Циклический избыточный код)
        
        [Циклический избыточный код - Википедия](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B8%D0%B7%D0%B1%D1%8B%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4)
        
    - Heartbeat
        
        ## Протокол Heartbeat[[править](https://ru.wikipedia.org/w/index.php?title=Heartbeat-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B5&veaction=edit&section=1) | [править код](https://ru.wikipedia.org/w/index.php?title=Heartbeat-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B5&action=edit&section=1)]
        
        Протокол Heartbeat обычно используется для просмотра и настройки доступности ресурсов, таких как [плавающий IP-адрес](https://ru.wikipedia.org/wiki/IP-%D0%B0%D0%B4%D1%80%D0%B5%D1%81). Обычно, когда на компьютере начинается heartbeat, он будет выполнять избирательный процесс с другими машинами в сети heartbeat, чтобы определить, какая машина, если таковая имеется, владеет ресурсом. На сетях heartbeat, состоящих из более чем двух машин, важно учитывать разделение, когда две половины сети могут работать, но не имеют возможности связаться друг с другом. В такой ситуации, важно, чтобы ресурс принадлежал только одной машине в сети, а не одной машине в каждом разделе.
        
        Так как heartbeat предназначен для использования, как указатель состояния машины, важно, чтобы протокол Heartbeat и кабель, на котором он работает, были как можно более надежными. Выполнение аварийного переключения, из-за ложной тревоги может быть, в зависимости от ресурса, крайне нежелательным. Важно также быстро реагировать на реальную неисправность, так что опять же важно, чтобы heartbeat являлся надежным. По этой причине часто желательно иметь heartbeat, работающий на более чем одном кабеле; например, на [Ethernet](https://ru.wikipedia.org/wiki/Ethernet) сегменте, используя [UDP](https://ru.wikipedia.org/wiki/UDP)/[IP](https://ru.wikipedia.org/wiki/IP), и [последовательном порте.](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D1%80%D1%82)
        
- Symfony
- Environment
    - Деплой на вебсервер через Капистрану
    - Capistrano
    - Clickhouse
    - Kibana
    - Rabbit
        
        [RabbitMQ для начинающих](https://proglib.io/w/c8551529)
        
        Иногда в веб-приложениях появляется необходимость выполнить сложные ресурсоемкие задачи, которые не могут быть умещены в коротком временном интервале HTTP запроса. В этом случае на помощь приходят очереди. Основная идея очередей – избежать выполнения ресурсоемких задач непосредственно после отправки запроса. Вместо этого задача ставится в очередь для последующего выполнения в асинхронном режиме. Т.е. при получении запроса от клиента мы инкапсулируем задачу как сообщение и отправляем его в очередь, а уже обработчик очереди достает сообщения в порядке их следования и обрабатывает надлежащим образом. Забегая вперед, скажу, что возможен режим работы очередей, когда при наличии нескольких копий обработчика, следующая задач будет поступать на свободный обработчик. Таким образом достигается распараллеливание выполнения задач.
        
        В данном разделе рассматривается работа с очередями, использующими сервер сообщений RabbitMQ. Сервер RabbitMQ по сути является менеджером очередей, который имеет следующие преимущества:
        
        - в случае некорректного завершения работы сервера, данные в очереди не теряются. И при последующем запуске обработка продолжается с того места, где был обрыв;
        - распределить задачи на несколько очередей, т.е. создать распараллеливание на уровне сообщений
        - если результат обработки не удовлетворяет, задачу можно послать в очередь повторно;
        - существует несколько режимов работы очереди: рассылка типа точка-точка(direct), рассылка сообщений по шаблону(topic), широковещательная рассылка сообщений(fanout);
        - возможность синхронизировать работу клиента и сервера, своего рода реализация RPC
        - количество хранимых в очереди сообщений неограничено
        - сервер сообщений может быть расположен удаленно как по отношению к продюсеру, так и по отношению к консьюмеру.
        
        В туториалах будут приведены примеры для всех вышеперечисленных вариантов. За основу взяты туториалы с официального сайта, дополнены и реализованы на PHP для [RabbitMQ](http://www.rabbitmq.com/getstarted.html).
        
        RabbitMQ испозует протокол AMQP. Чтобы использовть RabbitMQ необходимо поставить клиентскую и серверную части.
        
        # Установка сервера
        
        Для установки расширения AMQP для PHP необходимо сначала установить RabbitMQ Server
        
        Добавим следующию строку в файл /etc/apt/sources.list
        
        ```
        deb http://www.rabbitmq.com/debian/ testing main
        
        ```
        
        ```
        wget http://www.rabbitmq.com/rabbitmq-signing-key-public.asc
        sudo apt-key add rabbitmq-signing-key-public.asc
        sudo apt-get update
        sudo apt-get install rabbitmq-server
        ```
        
        [Symfony + RabbitMQ Быстрый старт для молодых](https://habr.com/ru/post/338950/)
        
    - Redis
        
        Очень часто Redis описывают как персистентное(то есть сохраняющееся после окончания работы создавшего его процессса-прим. перев.) хранилище данных типа ключ-значение в оперативной памяти. Я не думаю, что это совсем точное определение. Redis, действительно, держит все данные в памяти (позже мы вернемся к этому), и он сохраняет данные на диск для обеспечения персистентности. Но он не просто хранилище данных типа ключ-значение. Очень важно разобраться в этом неточном определении, иначе у вас сложится впечатление, что спектр решаемых Redis проблем весьма узок.
        Сутьвтом, что Redis предоставляет пять разных структур данных, только одна из которых собственно и есть структура типа ключ-значение. Понимание этих пяти структур данных, как они работают,какие методы они предоставляют для взаимодействия,и что вы сможете сделать с их помощью, как раз и являются путем к пониманию Redis. Но сначала давайте разберемся с тем, что же означает предоставление структур данных.
        Если мы применим эту концепцию к реляционному миру, мы можем сказать, что базы данных предоставляют один тип структур данных - таблицы. Таблицы одновременно сложные и гибкие. Существует очень мало вещей, которые нельзя смоделировать, сохранитьикоторыминельзяуправлятьспомощьютаблиц. Темнеменее,онинеидеальны. А именно, они не на столько простые, или не на столько быстрые, как хотелось бы. Что, если вместо универсальной структуры мы бы использовали специализированные структуры? В этом случае, наверное, найдутся проблемы, которые мы не сможем решить (или, по крайней мере, не сможем решить достаточно хорошо). Однако, в любом случае, мы выиграем на простоте и скорости.
        
        [Отказоустойчивая работа с Redis - Сергей Шамбир, iSpring](https://www.youtube.com/watch?v=9qvr920dWtk)
        
    - Кроны
        
        Кроны - механизм линукса, запускающий заданные команды по времени с заданной периодичностью
        
    - Работа сети через WebSocket
    - Как писать миграции баз данных
    - Как написать шедуллер
    - Докер контейнеры
        
        [Docker для начинающих — Полный курс 2021](https://www.notion.so/Docker-2021-a72201ec8573461c8a2e62e2fcf33aa3?pvs=21)
        
    - Работа на lxc
    - Концепция Middleware
    - Request, Response через  фабрику
    - FireBase
    - MapReducer в Mongo
    - Consumers
    - Worker
        
        [Workers (SymfonyCloud Docs)](https://symfony.com/doc/current/cloud/cookbooks/workers.html)
        
        [Worker-ы и shared worker-ы](https://habr.com/ru/post/261307/)
        
- Фронт
    - NUXT JS
        
        [Nuxt.js - Универсальные приложения на Vue.js](https://ru.nuxtjs.org/)
        
- Based
    
    Statefull and Stateless
    
    [Stateful vs Stateless: Full Difference](https://www.interviewbit.com/blog/stateful-vs-stateless/)